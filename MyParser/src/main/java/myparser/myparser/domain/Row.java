package myparser.myparser.domain;

import myparser.myparser.types.Type;
import myparser.myparser.types.EventType;
import myparser.myparser.types.DamageType;
import java.time.LocalTime;
import java.util.Objects;

/**
 * object contains all information from a specific Row
 * <p>
 * Note can only generate rows version for logs in English
 * <p>
 * Example Row, :
 * <p>
 * <b>[22:59:40.842] [@Blonde'kate] [@Firaksîan] [Recuperative Nanotech
 * {815232037421056}] [ApplyEffect {836045448945477}: Heal {836045448945500}]
 * (1821*) <122></b>
 * <p>
 * Row fields on the example Row
 * <p>
 * <b>timestamp: 22:59:40.842</b>
 * <p>
 * <b>Source: @Blonde'kate </b> source of the effect on the Row. Note player characters
 * always have @ in front
 * <p>
 * <b>Target: @Firaksîan</b>, target of Row,
 * <p>
 * <b>abilityName: Recuperative Nanotech</b>, {815232037421056} is an id which is the same
 * for all languages of the game (this class works only for english logs)
 * <p>
 * <b>Type: ApplyEffect</b>, see class Type for all possibilities. All dmgHeal and
 * healing is "applyEffect" type
 * <p>
 * <b>eventType: null</b>, used for Rows which are of Type Event. For non event rows
 * null
 * <p>
 * <b>effectType: Heal</b>, for Rows which are an effect (applyEffect or removeEffect).
 * Null for non-effect rows
 * <p>
 * <b>dmgHeal: 1821</b>, amount of dmgHeal or heal of the row. 0 for misses and non
 * attack/heals
 * <p>
 * <b>threat: 121</b>, threat generated by row
 * <p>
 * <b>shielded and miss: false</b> true for Rows which were missed or shielded
 *
 *
 * <p>
 * Note: Effecttype or EventType is always null, as Row is either an Event or an
 * <p>
 * Effect (both are null, in case of energy management rows) No other value on
 * the row can be null. Abilityname, source and target are empty in case of no
 * name/target/source
 */
public class Row {

    private final LocalTime timestamp;
    private String source;
    private String target;
    private final Type type;
    private String effecttype;
    private EventType eventtype;
    private final String abilityName;
    private int dmgHeal;
    private int threat;
    private boolean crit;
    private DamageType dmgType;
    private boolean shielded;
    private final int rowNumber;

    /**
     * determines if this row is a miss or not, by looking at dmgType
     *
     * @return
     */
    public boolean isMiss() {
        if (this.dmgType == null) {
            return false;
        }

        if (this.dmgType == DamageType.miss || this.dmgType == DamageType.dodge || this.dmgType == DamageType.resist) { //diffrent possible ways to miss attacks
            return true;
        }
        return false;

    }

    /**
     * Construct a row from given parameters
     * <p>
     *
     * @param timestamp
     * @param source
     * @param target
     * @param type
     * @param effecttype
     * @param eventtype
     * @param abilityName
     * @param dmgHeal
     * @param crit
     * @param shielded
     * @param rowNumber
     * @param threat
     * @param dmgType
     */
    public Row(LocalTime timestamp, String source, String target, Type type, String effecttype, EventType eventtype, String abilityName, int dmgHeal, boolean crit, boolean shielded, int rowNumber, int threat, DamageType dmgType) {
        this.timestamp = timestamp;
        this.source = source;
        this.target = target;
        this.type = type;
        this.effecttype = effecttype;
        this.eventtype = eventtype;
        this.abilityName = abilityName;
        this.dmgHeal = dmgHeal;
        this.crit = crit;
        this.shielded = shielded;
        this.rowNumber = rowNumber;
        this.threat = threat;
        this.dmgType = dmgType;

    }

    /**
     *
     * Create a new row from a rawline and row number (row numbers are only used
     * for making sure rows are in the correct order when reading from database)
     * <p>
     * Exceptions should only be thrown in case user has modified the rawline
     * for some reason (or if the line being read is not from a valid combat
     * log)
     *
     *
     * @param rawline
     * @param rowNumber
     * @throws IndexOutOfBoundsException
     * @throws NumberFormatException
     * @throws IllegalArgumentException
     */
    public Row(String rawline, int rowNumber) throws IndexOutOfBoundsException, NumberFormatException, IllegalArgumentException {
        this.rowNumber = rowNumber;
        //these values are changed later if  needed
        this.threat = 0;
        this.crit = false;
        this.shielded = false;

        //rawline example:
        //[23:15:12.081] [@Predori] [@Firaksîan] [Resurgence {3412162538110976}] [ApplyEffect {836045448945477}: Heal {836045448945500}] (2107*)
        //Parse line by checking 1 element at a time (elements between [])
        this.timestamp = LocalTime.parse(getNextElement(rawline)[0]);
        String notParsedLine = getNextElement(rawline)[1];

        String rawSource = getNextElement(notParsedLine)[0];
        notParsedLine = getNextElement(notParsedLine)[1];

        this.source = removeId(rawSource);

        String rawTarget = getNextElement(notParsedLine)[0];
        notParsedLine = getNextElement(notParsedLine)[1];

        this.target = removeId(rawTarget);

        String rawName = getNextElement(notParsedLine)[0];
        notParsedLine = getNextElement(notParsedLine)[1];

        this.abilityName = removeId(rawName);

        String rawType = getNextElement(notParsedLine)[0]; //rawtype format, [ApplyEffect {836045448945477}: Heal {836045448945500}]

        String[] typeParts = rawType.split(":");

        notParsedLine = getNextElement(notParsedLine)[1];

        this.type = Type.valueOf(removeId(typeParts[0]));

        String afterType = typeParts[1].trim();
        if (this.type == Type.Event) {
            this.eventtype = EventType.valueOf(removeId(afterType));
            this.effecttype = null;
        } else if (this.type == Type.ApplyEffect || Type.RemoveEffect == this.type) {   //All dmgHeal and healing is ApplyEffect
            this.eventtype = null;
            this.effecttype = removeId(afterType);
            //as all dmg and healing is applyEffect, setting all dmgHeal and healing related things here
            if (this.effecttype.equals("Heal") || this.effecttype.equals("Damage")) {

                this.setDmgHeal(notParsedLine);
            }
        } else {
            //this should happen only with resource lines (energy/rage/heat etc usage).
            this.eventtype = null;
            this.effecttype = null;
        }

        //As sudden death contamination is not technically a dmg type (and not marked on the log at all), and so it's not caught by the above method of checking for dmg type, we are checking for it here
        //Example rawline: [23:06:19.465] [] [@Firaksîan] [Sudden Death Toxic Contamination {3291448187289600}] [ApplyEffect {836045448945477}: Damage {836045448945501}] (1792 )
        if (this.abilityName.equals("Sudden Death Toxic Contamination")) {
            this.dmgType = DamageType.contamination;
            this.source = "Sudden death"; //name is empty normally 
        }

    }

    @Override
    public String toString() {
        String output = "";
        output += String.valueOf(this.rowNumber) + ", " + this.timestamp + " , " + this.source + " , " + this.target + " , " + this.abilityName + " , " + this.type;
        if (this.eventtype != null) {
            output += " , " + this.eventtype;
        } else if (this.effecttype != null) {
            output += " , " + this.effecttype;
            if (this.effecttype.equals("Heal") || this.effecttype.equals("Damage")) {
                output += " , " + this.dmgHeal;
            }
        }
        if (this.crit) {
            output += "*";
        }
        return output;
    }

    public LocalTime getTimestamp() {
        return timestamp;
    }

    public String getTarget() {
        return target;
    }

    public String getAbilityName() {
        return abilityName;
    }

    public int getDmgHeal() {
        return dmgHeal;
    }

    public Type getType() {
        return type;
    }

    public String getEffecttype() {
        return effecttype;
    }

    public EventType getEventtype() {
        return eventtype;
    }

    public String getSource() {
        return source;
    }

    public int getThreat() {
        return threat;
    }

    public boolean isCrit() {
        return crit;
    }

    public DamageType getDmgType() {
        return dmgType;
    }

    /**
     * set dmgHeal, dmgType, shielded and crit to match notParsedLine
     * <p>
     * notParsedLine must be format, Damage {836045448945501}] (5732* energy
     * {836045448940874}
     * <p>
     * Meaning the last part of effectType
     *
     * @param notParsedLine
     */
    private void setDmgHeal(String notParsedLine) {
        //Heal and dmgHeal are in diffrent formats , reflected , aborbed dmgHeal is in a diffrent format and a few heals ( such as resurrection) are in the same format as dmgHeal 
        if (notParsedLine.contains("shield")) {
            this.shielded = true;
        } else {
            this.shielded = false;
        }
        // unparsedLine format at this point for shielded dmg rows: (742* energy {836045448940874} -shield {836045448945509} (515 absorbed {836045448945511})) <742> 
        // or unshielded dmg rows (and rare heal rows, resurrection): (112 energy {836045448940874}) <1121>

        //for Healing rows, unParsedLine is:  (1821*)
        //notice whitespace for healing rows
        //crits are marked with *
        String[] lineParts = notParsedLine.trim().split(" "); //NOTE array length is not fixed, as all rows don't contain shield, absorbed etc. But the size of the hit/heal is always first
        String dmgHeal = lineParts[0];
        if (lineParts.length >= 2) {    //Almost all healing rows (all except resurrection have length of 1)
            try {

                this.dmgType = DamageType.valueOf(lineParts[1].replace("-", ""));
            } catch (IllegalArgumentException e) {

                //Happends for rare healing rows (Resurrection)
                //and sudden death (see last line in constructor)
                this.dmgType = null;
            }

        }
        dmgHeal = dmgHeal.replace("(", "");
        dmgHeal = dmgHeal.replace(")", "");

        if (dmgHeal.contains("*")) { //crits marked with *

            this.crit = true;
            dmgHeal = dmgHeal.substring(0, dmgHeal.length() - 1);
        } else {
            this.crit = false;
        }
        this.dmgHeal = Integer.valueOf(dmgHeal.trim());

        //Threat is always the last in a line, if there is any
        String lastPart = lineParts[lineParts.length - 1];
        if (lastPart.contains("<")) {
            try {
                this.threat = Integer.valueOf(lastPart.substring(lastPart.lastIndexOf("<") + 1, lastPart.lastIndexOf(">")));
            } catch (NumberFormatException | IndexOutOfBoundsException e) {
                this.threat = 0;
            }
        } else {
            this.threat = 0;
        }

    }

    /**
     * remove id from element (string between {}) if no id found, return
     * original String
     *
     * @param element
     * @return String
     */
    private static String removeId(String element) {
        if (element.contains("{")) {
            element = element.substring(0, element.indexOf("{"));
        }
        return element.trim();
    }

    /**
     * returns an array, at 0 index is next element in the rawline (information
     * contained between []), at index 1 is the remaining String
     * <p>
     * returns empty string and original String, if no [ or ] in parameter
     * String
     *
     * @param rawline
     * @return
     */
    private static String[] getNextElement(String rawline) {
        String[] parts = new String[2];
        try {
            int index1 = rawline.indexOf("[");
            int index2 = rawline.indexOf("]");
            parts[0] = rawline.substring(index1 + 1, index2).trim();
            parts[1] = rawline.substring(index2 + 1, rawline.length()).trim();
        } catch (IndexOutOfBoundsException e) {
            parts[0] = "";
            parts[1] = rawline;
        }
        return parts;
    }

    public boolean isShielded() {
        return shielded;
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 17 * hash + Objects.hashCode(this.timestamp);
        hash = 17 * hash + Objects.hashCode(this.source);
        hash = 17 * hash + Objects.hashCode(this.target);
        hash = 17 * hash + Objects.hashCode(this.type);
        hash = 17 * hash + Objects.hashCode(this.effecttype);
        hash = 17 * hash + Objects.hashCode(this.eventtype);
        hash = 17 * hash + Objects.hashCode(this.abilityName);
        hash = 17 * hash + this.dmgHeal;
        hash = 17 * hash + this.threat;
        hash = 17 * hash + (this.crit ? 1 : 0);
        hash = 17 * hash + Objects.hashCode(this.dmgType);
        hash = 17 * hash + (this.shielded ? 1 : 0);
        return hash;
    }

    //Equals method mainly for unit tests
    //this method is split is in 5 because Checkstyle
    /**
     * Rows are equal if all values inside are equal
     *
     * @param obj
     * @return
     */
    @Override
    public boolean equals(Object obj) {
        if (!this.checkClass(obj)) {
            return false;
        }
        final Row other = (Row) obj;
        if (!this.checkDmg(other)) {
            return false;
        }

        if (!this.checkTypes(other)) {
            return false;
        }
        if (!this.checkSourceTargetAbility(other)) {
            return false;
        }

        if (!Objects.equals(this.timestamp, other.timestamp)) {
            return false;
        }

        return true;
    }

    private boolean checkSourceTargetAbility(Row other) {
        if (!Objects.equals(this.source, other.getSource())) {
            return false;
        }
        if (!Objects.equals(this.target, other.getTarget())) {
            return false;
        }

        if (!Objects.equals(this.abilityName, other.getAbilityName())) {
            return false;
        }
        return true;
    }

    private boolean checkClass(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        return true;
    }

    private boolean checkDmg(Row other) {
        if (this.threat != other.getThreat()) {
            return false;
        }

        if (this.dmgHeal != other.getDmgHeal()) {
            return false;
        }
        if (this.crit != other.isCrit()) {
            return false;
        }
        if (this.shielded != other.isShielded()) {
            return false;
        }
        return true;
    }

    private boolean checkTypes(Row other) {
        if (!Objects.equals(this.effecttype, other.getEffecttype())) {
            return false;
        }
        if (this.type != other.getType()) {
            return false;
        }
        if (this.eventtype != other.getEventtype()) {
            return false;
        }
        if (this.dmgType != other.getDmgType()) {
            return false;
        }
        return true;
    }

    public int getRowNumber() {
        return rowNumber;
    }

}
