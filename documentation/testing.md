# Testausdokumentti

The application has been tested manuallly and with Junit unit testes

## Unit - and Integration tests

### Application logic

Most of the application logic (meaning classes in domain, reader and stats packages) have been tested with automated unit tests. 
Row tests have been fully automated, and they check that the information Row parses from a rawline from a log contains the correct information.
Currently Row hasn't been extensively tested with fake user input, such as lines that are not from log files, but seeing as combat logs follow a very strict format in how they are written, unless an user was deliberatelly trying to trick the class (which of course is possible if the user simply edits an exsisting combat log)
there is no chance that Row class could for instance read line randomly generated by the user and not raise some exception.
The only case which has been tested (manually) is weird user names, but as stated before the format of a combat log is very strict
and player names are clearly marked as such, there is no chance an unusual charecter name could cause the application to behave
unpredictably, and therefore this possibility was not tested outside very light manual testing.

Reader class was purely automated to both read the correct amount of lines, number lines correctly and mark the start and end of 
fights correctly. This was done with unit tests, and a few sample logs. To ensure that the Reader read lines correctly, the two
logs used for testing test.txt and test2.txt in [test](MyParser/src/test) were manually looked through, to see the correct amount 
of fights Reader should find, and how many rows belong to each fight. In case of test.txt, as it was made to be a small log file
rows were also checked to be correct. In case of test2.txt, as it was chosen to be a very long file, only that the correct amount of fights
returned, as well as the first few fights having the correct amount of rows was checked. The fights that were not automaitcally tested, were tested
manually (to see each fight ended and started on the correct row)  
One note about charecter encoding, currently Reader will break if given input that is not encoded with ISO-8859-1,
which was tested, and the gui will notify the user that the file they attempted to read was not a log file.  

### Gui

Gui was tested manually to show the correct information to the user, as well as to provide the user with a pop-up error message for 
diffrent potential misuses I could think of (file not a log file, user doesn't have permission to use file, database is in use, etc.).
Currently if the user attempts to use application with a diffrent .mv.db file that one created by this application, the error
message suggets that the database might be in use (as well as the error generated by java, which in this would be something like TABLE NOT FOUND)
but seeing as the user would unlikely have extra .mv.db files (and if they do they can probably guess the problem from the java error message)  

### Database

Database was tested by creating a test database, and inserting a large (previously used test2.txt) into the database, then reading
the information from the database, and finally checking that each row created by the database matched the row for the same line generated by the Reader
(and that the rows read from the database were in the correct order)

### Test coverage

Appart from the gui, approximetelly 76 % of lines, and 69 % of branches were covered by automated tests.
In domain, while the line coverage is only 68 % and branch coverage 68 %, the only lines in the domain that are not tested in 
hashcode and toString methods of Row and Fight. As neither of these are used by the application in anyway (toString methods are there for manual testing
as well to make Junit error messages more readable, and hashcode is there in case it's needed in the future) it was not considered
necessary to test these methods in anyway.  
Most of the missed branches belong to the 2 methods mentioned below, as well the equals methods for both classes. As the equals methods are both
automaically generated, and very simple (and not used for anything other than testing) it wasn't deemed necessary to write tests, just to check
that every possible branch of the equals metho worked as intended.  
There are also a few missed branches in the Fight constructor, relating to the NoOwnerException, and when it's thrown. As this is an exception that will
never occur during normal use of the application (there is currently no way for the application to throw this exception, except in a case
where after the user has inserted a fight into the database with the application, accessed the same file, and then deleted all rows relating to the start and end of fights
as well as entries were the row target and source are the same player, with some other application capable of executing sql commands)
This was not deemed an useful way to test the application. (it is tested, that the application can determine an owner for the log, and that
this exception is never thrown)

stats package coverage is currenly only 67 %. The Tuple class has only a 17 % coverage, but this because the toString, hashcode and equals methods
are not used by the current application in anyway (excpet for manual testing), so their testing was deemed unnecessary.  
The abstact class Stats has currently several new methods that were added to support the damage taken tab added in this release,
and due to time constrains there wasn't enough time to automate tests for these methods, but were all manually tested, to
show corrext values


### Installation and configuration

The application has been tested with the binary for the latest release, to not crash under any error we could reproduce, and in all errors a pop
expaining the potential cause is given to the user (as well as the java error message, in case the user wants to try to solve the problem themselves, most likely
useful with IoExcpetion retaining to javafx). The only errors written on the command line are in case the classLoader fails to load javafx for some reason
(shouldn't happen with java8). However, since javafx has internal error handeling, and all exception that happen during runtime
are never thrown to the original classloader, but handled inside the framework, and the javafx default error handling is printing the stacktrace on the command line,
should this or a future release have an error not accounted for, it would print out an unuserfriendly stacktrace on the commandline
(future releases should look to javafx documentation to work around this issue)

## Remaining problems  

All problems currently found, but without a solution are presented (mainly javafx internal error handling)
